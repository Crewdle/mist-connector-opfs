!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var r=t();for(var a in r)("object"==typeof exports?exports:e)[a]=r[a]}}(this,(()=>(()=>{"use strict";var e={d:(t,r)=>{for(var a in r)e.o(r,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:r[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{OPFSObjectStoreConnector:()=>c});const r=require("@crewdle/web-sdk-types");function a(e){return e.split("/").filter((e=>e.length>0))}function i(e,t){return"/"===e?e+t:e+"/"+t}function n(e){const t=a(e),r=t.pop()||"",i=t.join("/");return[0===i.length?"/":i,r]}class o{reader;constructor(e){this.reader=e.getReader()}async read(){const{done:e,value:t}=await this.reader.read();return e?null:t}async close(){await this.reader.cancel(),this.reader.releaseLock()}}class s{file;name;size;type;lastModified;constructor(e){this.file=e,this.name=e.name,this.size=e.size,this.type=e.type,this.lastModified=e.lastModified}arrayBuffer(){return this.file.arrayBuffer()}text(){return this.file.text()}slice(e,t,r){return this.file.slice(e,t,r)}stream(){return new o(this.file.stream())}}class l{writable;closed=!1;constructor(e){this.writable=e}async write(e){await this.writable.write(e)}async close(){this.closed||(this.closed=!0,this.writable.locked&&await new Promise((e=>{const t=setInterval((()=>{this.writable.locked||(e(),clearInterval(t))}))})),await this.writable.close())}}class c{storeKey;root;constructor(e){this.storeKey=e}async get(e){const[t,r]=await this.getFolderHandle(e);for await(const a of t.values())if(a.name===r){if("directory"===a.kind)throw new Error(`Cannot get file: ${e}`);{const e=await t.getFileHandle(r),a=await e.getFile();return new s(a)}}throw new Error(`Cannot get file: ${e}`)}async list(e,t=!1){try{const a=[],[i,n,o]=await this.getFolderHandle(e),s="/"===e?i:await i.getDirectoryHandle(n);for await(const e of s.values()){const i="/"+(o.length>0?o.join("/"):""),n=i.length>1?i+"/"+e.name:"/"+e.name;if("directory"===e.kind)a.push({kind:r.ObjectKind.Folder,name:e.name,path:i,pathName:n,entries:t?await this.list(n,t):[]});else{const t=await s.getFileHandle(e.name),o=await t.getFile();a.push({kind:r.ObjectKind.File,name:e.name,type:o.type,size:o.size,path:i,pathName:n,status:r.FileStatus.Synced})}}return a}catch(t){throw new Error(`Cannot list folder: ${e}`)}}async createFolder(e){try{await this.getOrCreateFolderHandle(e);const[t,a]=n(e);return{kind:r.ObjectKind.Folder,name:a,path:t,pathName:e}}catch(t){throw new Error(`Cannot create folder: ${e}`)}}async writeFile(e,t){try{const a=await this.getOrCreateFolderHandle(t),n=await a.getFileHandle(e.name,{create:!0}),o=await n.createWritable();return await o.write(e),await o.close(),{kind:r.ObjectKind.File,name:e.name,type:e.type,size:e.size,path:t??"/",pathName:i(t??"/",e.name),status:r.FileStatus.Synced}}catch(r){throw new Error(`Cannot write file: ${i(t??"/",e.name)}`)}}async createWritableStream(e){const[t,r]=n(e),a=await this.getOrCreateFolderHandle(t),i=await a.getFileHandle(r,{create:!0}),o=await i.createWritable();return new l(o)}async deleteObject(e){const[t,a]=await this.getFolderHandle(e);for await(const i of t.values())if(i.name===a)try{return"directory"===i.kind?(await t.removeEntry(a,{recursive:!0}),r.ObjectKind.Folder):(await t.removeEntry(a),r.ObjectKind.File)}catch(t){throw new Error(`Cannot delete file: ${e}`)}throw new Error(`Cannot delete file: ${e}`)}async moveObject(e,t){try{const[a,i]=await this.getFolderHandle(e);for await(const n of a.values())if(n.name===i){if("directory"===n.kind)return await this.moveDirectory(a,e,t),r.ObjectKind.Folder;{const n=await a.getFileHandle(i);return await this.moveFile(n,e,t),r.ObjectKind.File}}throw new Error(`Cannot move object: ${e}`)}catch(t){throw new Error(`Cannot publish move operation: ${e}`)}}async calculateSize(e){const t=await this.list(e);let a=0;for(const e of t)e.kind===r.ObjectKind.File?a+=e.size:a+=await this.calculateSize(e.pathName);return a}async getOrCreateFolderHandle(e){try{let t=await this.getRootFolderHandle();if(e){const r=a(e);for(const e of r)t=await t.getDirectoryHandle(e,{create:!0})}return t}catch(t){throw new Error(`Cannot get or create folder: ${e}`)}}async getRootFolderHandle(){if(this.root)return this.root;const e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.storeKey,{create:!0}),this.root}async getFolderHandle(e){try{let t=await this.getRootFolderHandle();if("/"===e)return[t,"",[]];const r=a(e);for(const[e,a]of r.entries()){if(e===r.length-1)return[t,a,r];t=await t.getDirectoryHandle(a)}}catch(t){throw new Error(`Cannot get folder: ${e}`)}throw new Error(`Cannot get folder: ${e}`)}async moveFile(e,t,r){try{const a=await e.getFile(),i=r.split("/"),n=i.slice(-1),o=i.slice(0,i.length-1).join("/"),s=new File([a],n[0],{type:a.type});await this.writeFile(s,o),await this.deleteObject(t)}catch(e){throw new Error(`Cannot move file: ${t}`)}}async moveDirectory(e,t,r){try{await this.getOrCreateFolderHandle(r);const[a,i]=n(t),o=await e.getDirectoryHandle(i);await this.copyDirectory(o,t,r),await this.deleteObject(t)}catch(e){throw new Error(`Cannot move folder: ${t}`)}}async copyDirectory(e,t,a){const n=await this.list(t,!1);for(const t of n)if(t.kind===r.ObjectKind.Folder)await this.moveDirectory(e,t.pathName,i(a,t.name));else{const r=await e.getFileHandle(t.name);await this.moveFile(r,t.pathName,i(a,t.name))}}}return t})()));